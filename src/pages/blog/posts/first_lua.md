---
layout: "../../../layouts/BlogPostLayout.astro"
title: "Что такое Lua и с чем его едят"
author: "Maxim Minaev"
date: "14 Apr 2023"
draft: false
lang: ru
---
# Что такое Lua и с чем его едят

Lua — скриптовый интерпретируемый язык с динамической типизацией созданный в 1993 на языке C.
упарвление памятью

Чаще всего используется как встаиваемый язык, поэтому у него нет собственной среды выполнения, а сам интерпретатор `lua` написан с использованием либы **[C API](https://www.lua.org/pil/24.html)**. Её же и используют для взаимодействия с другими языками программирования и средами выполнения, но об этом позже.

Например на Lua пишутся аддоны для World Of Warcraft, Redis умеет читать и исполнять lua-скрипты, модули для Nginx, плагины для NeoVim, и так далее.

## Синтаксис
Классический `Hello, World!` выглядит так
```lua
print("Hello, World!")
```

Синтаксис Lua является паскале-образным с данимическим выводом типов и подходит для быстрого прототипирования. Все синтаксические конструкции должны завершаться ключевым словом `end`. А переменные бывают *локальным* и *глобальными*.

Локальные переменные объявляются с ключевым словом `local` и доступны в пределах зоны видимости блока кода или отдельного скрипта.

Все остальные являются глобальными и доступны до тех пор пока существует **среда выполнения кода**.

Все глобальные переменные добавляются в зарезервированную таблицу `_G` и после доступны через неё при исполнении других скриптов в пределах одной среды.

В качестве примера приведу решение [Advent Of Code 2022 Day 1](https://adventofcode.com/2022/day/1)
```lua
local max, current = 0, 0
for line in io.lines("input.txt") do
	if line == "" then
		if current > max then
			max = current
		end
		current = 0
	else
		current = current + tonumber(line)
	end
end

if current > max then
	max = current
end

print(max)
```

## Типы данных

в Lua есть 8 базовых типов данных:

`number`, `string`, `boolean`, `nil`, `function`, `table`, `thread`, `userdata`, 

Некоторые особенности:
- `number` не разделяется на целые числа и числа с плавающей точкой, все считаются number
	встроенная функция приведения к числу `tonumber(s)`
- `string` строки являются иммутабельными
- `table` объединяют в себе словари, массивы, объекты (в том числе классов)
- `thread` относится к корутинам модуля `coroutine`
- `userdata` представляет собой указатель на блок памяти и используется для доступа к внешней среде выполнения

### **[C API](https://www.lua.org/pil/24.html)** и встаивание кода
**C API** является библиотекой для запуска кода на языке `Lua` из программ на языке `C`. Существует много портов этой библиотеки на любые языки программирования, но большинство придерживается основого флоу взаимодействия с использованием разной степени абстракций.

Всё начинается с создания среды выполнения `lua_State`. дальше все взаимодействие с программой будет идти с помощью стэка внутри `lua_State`.

В стэк мы будем туда аргументы для вызова функций и идентификаторы функций, оттуда мы будем доставать результаты выполнения функций, файлов.

Дальше в примерах я буду использовать пакет [github.com/yuin/gopher-lua](https://github.com/yuin/gopher-lua) для языка Go

Предположим у нас есть lua файл который считает чисто Фиббоначи и возвращает результат для числа 5
```lua
-- fib5.lua
function fib(n)
    local fib = {1, 1} 
    for i = 3,n,1 do
        fib[#fib+1] = fib[#fib] + fib[#fib-1]
    end
    return fib[n]
end
return fib(5)
```
Вот как можно получить результат из Go
```go
package main

import (
	"fmt"

	lua "github.com/yuin/gopher-lua"
)

func main() {
	var L *lua.LState = lua.NewState()
	defer L.Close()
	if err := L.DoFile("fib5.lua"); err != nil {
		panic(err)
	}

	// тут мы достаем результат выполнения последнего положения стэка
	result := L.Get(-1)
	// а тут очищаем его
	L.Pop(1)
	fmt.Printf("result: %d\n", result) // result: 5
}
```
Eсли мы захотим заново выполнить подсчет, то нам не надо заново загружать файл чтобы загрузить функцию `fib(n)` 
нужно только положить в стэк функцию из глобальных переменных, аргумент и прозвести вызов c помощью `Call(nargs, nrets)`
```go
...
fmt.Printf("result: %d\n", result) // result: 5

L.Push(L.GetGlobal("fib")) // stack: function "fib"
//складываем на стэк аргумент функции
L.Push(lua.LNumber(15))    // stack: function "fib", 15
// L.Call забирает из стэка функцию и 1 аргумент, и складывает обратно 1 результат
L.Call(1, 1)               // stack: 610
result = L.Get(-1)         // stack: 610
L.Pop(1)                   // stack:
fmt.Printf("result: %d\n", result) //result: 610
```
### Заключение
